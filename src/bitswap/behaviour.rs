//! Handles the `/ipfs/bitswap/1.0.0` and `/ipfs/bitswap/1.1.0` protocols. This
//! allows exchanging IPFS blocks.
//!
//! # Usage
//!
//! The `Bitswap` struct implements the `NetworkBehaviour` trait. When used, it
//! will allow providing and reciving IPFS blocks.
use futures::prelude::*;
use libp2p::core::swarm::{
    ConnectedPoint, NetworkBehaviour, NetworkBehaviourAction, PollParameters,
};
use libp2p::core::protocols_handler::ProtocolsHandler;
use libp2p::{Multiaddr, PeerId};
use std::marker::PhantomData;
use tokio::prelude::*;

/// Network behaviour that handles sending and receiving IPFS blocks.
pub struct Bitswap<TSubstream> {
    /// Marker to pin the generics.
    marker: PhantomData<TSubstream>,
    /// Queue of events to report to the user.
    events: Vec<BitswapEvent>,
}

/// Event generated by the `Bitswap` behaviour.
pub enum BitswapEvent {

}

impl<TSubstream> Bitswap<TSubstream> {
    /// Creates a `Bitswap`.
    pub fn new() -> Self {
        Bitswap {
            marker: PhantomData,
            events: Vec::new(),
        }
    }
}

impl<TSubstream> Default for Bitswap<TSubstream> {
    #[inline]
    fn default() -> Self {
        Bitswap::new()
    }
}

impl<TSubstream> NetworkBehaviour for Bitswap<TSubstream>
where
    TSubstream: AsyncRead + AsyncWrite,
{
    type ProtocolsHandler = ();
    type OutEvent = BitswapEvent;

    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        ()
    }

    fn addresses_of_peer(&mut self, _peer_id: &PeerId) -> Vec<Multiaddr> {
        Vec::new()
    }

    fn inject_connected(&mut self, _: PeerId, _: ConnectedPoint) {}

    fn inject_disconnected(&mut self, _: &PeerId, _: ConnectedPoint) {}

    fn inject_node_event(
        &mut self,
        source: PeerId,
        event: <Self::ProtocolsHandler as ProtocolsHandler>::OutEvent,
    ) {
    }

    fn poll(
        &mut self,
        _: &mut PollParameters,
    ) -> Async<NetworkBehaviourAction<
            <Self::ProtocolsHandler as ProtocolsHandler>::InEvent, Self::OutEvent>> {
        if !self.events.is_empty() {
            let event = self.events.remove(0);
            return Async::Ready(NetworkBehaviourAction::GenerateEvent(event));
        }

        Async::NotReady
    }
}
