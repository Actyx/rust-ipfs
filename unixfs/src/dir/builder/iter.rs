use super::{DirBuilder, Entry, Leaf, TreeConstructionFailed, TreeOptions};
use cid::Cid;
use std::collections::HashMap;
use std::fmt;

/// Constructs the directory nodes required for a tree.
///
/// Implements the Iterator interface for owned values and the borrowed version, `next_borrowed`.
/// The tree is fully constructed once this has been exhausted.
pub struct PostOrderIterator {
    full_path: String,
    old_depth: usize,
    block_buffer: Vec<u8>,
    // our stack of pending work
    pending: Vec<Visited>,
    // "communication channel" from nested entries back to their parents this hashmap is only used
    // in the event of mixed child nodes (leaves and nodes).
    persisted_cids: HashMap<u64, Vec<Option<NamedLeaf>>>,
    reused_children: Vec<Visited>,
    cid: Option<Cid>,
    total_size: u64,
    // from TreeOptions
    opts: TreeOptions,
}

type Leaves = Vec<Option<NamedLeaf>>;

#[derive(Debug)]
struct NamedLeaf(String, Cid, u64);

#[derive(Debug)]
enum Visited {
    // handle root differently not to infect everything with the Option<String> and so on
    DescentRoot(DirBuilder),
    Descent {
        node: DirBuilder,
        name: String,
        depth: usize,
        index: usize,
    },
    Post {
        parent_id: u64,
        depth: usize,
        name: String,
        index: usize,
        leaves: LeafStorage,
    },
    PostRoot {
        leaves: LeafStorage,
    },
}

impl PostOrderIterator {
    pub(super) fn new(root: DirBuilder, opts: TreeOptions, longest_path: usize) -> Self {
        let root = Visited::DescentRoot(root);
        PostOrderIterator {
            full_path: String::with_capacity(longest_path),
            old_depth: 0,
            block_buffer: Default::default(),
            pending: vec![root],
            persisted_cids: Default::default(),
            reused_children: Vec::new(),
            cid: None,
            total_size: 0,
            opts,
        }
    }

    fn render_directory(
        links: &[Option<NamedLeaf>],
        buffer: &mut Vec<u8>,
        block_size_limit: &Option<u64>,
    ) -> Result<Leaf, TreeConstructionFailed> {
        use crate::pb::{UnixFs, UnixFsType};
        use quick_protobuf::{BytesWriter, MessageWrite, Writer, WriterBackend};
        use sha2::{Digest, Sha256};

        // FIXME: ideas on how to turn this into a HAMT sharding on some heuristic. we probably
        // need to introduce states in to the "iterator":
        //
        // 1. bucketization
        // 2. another post order visit of the buckets?
        //
        // the nested post order visit should probably re-use the existing infra ("message
        // passing") and new ids can be generated by giving this iterator the counter from
        // BufferedTreeBuilder.
        //
        // could also be that the HAMT shard building should start earlier, since the same
        // heuristic can be detected *at* bufferedtreewriter. there the split would be easier, and
        // this would "just" be a single node rendering, and not need any additional states..

        /// Newtype around Cid to allow embedding it as PBLink::Hash without allocating a vector.
        struct WriteableCid<'a>(&'a Cid);

        impl<'a> MessageWrite for WriteableCid<'a> {
            fn get_size(&self) -> usize {
                use cid::Version::*;
                use quick_protobuf::sizeofs::*;

                let hash_len = self.0.hash().as_bytes().len();

                match self.0.version() {
                    V0 => hash_len,
                    V1 => {
                        let version_len = 1;
                        let codec_len = sizeof_varint(u64::from(self.0.codec()));
                        version_len + codec_len + hash_len
                    }
                }
            }

            fn write_message<W: WriterBackend>(
                &self,
                w: &mut Writer<W>,
            ) -> quick_protobuf::Result<()> {
                use cid::Version::*;

                match self.0.version() {
                    V0 => self
                        .0
                        .hash()
                        .as_bytes()
                        .iter()
                        .try_for_each(|b| w.write_u8(*b)),
                    V1 => {
                        // it is possible that Cidv1 should not be linked to from a unixfs
                        // directory; at least go-ipfs 0.5 `ipfs files` denies making a cbor link
                        w.write_u8(1)?;
                        w.write_varint(u64::from(self.0.codec()))?;
                        self.0
                            .hash()
                            .as_bytes()
                            .iter()
                            .try_for_each(|b| w.write_u8(*b))
                    }
                }
            }
        }

        /// Newtype which uses the BTreeMap<String, Leaf> as Vec<PBLink>.
        struct BTreeMappedDir<'a> {
            links: &'a [Option<NamedLeaf>],
            data: UnixFs<'a>,
        }

        /// Newtype which represents an entry from BTreeMap<String, Leaf> as PBLink as far as the
        /// protobuf representation goes.
        struct EntryAsPBLink<'a>(&'a NamedLeaf);

        impl<'a> MessageWrite for EntryAsPBLink<'a> {
            fn get_size(&self) -> usize {
                use quick_protobuf::sizeofs::*;

                // ones are the tags
                1 + sizeof_len((self.0).0.len())
                    + 1
                    + sizeof_len(WriteableCid(&(self.0).1).get_size())
                    //+ sizeof_len(self.1.link.to_bytes().len())
                    + 1
                    + sizeof_varint((self.0).2)
            }

            fn write_message<W: WriterBackend>(
                &self,
                w: &mut Writer<W>,
            ) -> quick_protobuf::Result<()> {
                w.write_with_tag(10, |w| w.write_message(&WriteableCid(&(self.0).1)))?;
                //w.write_with_tag(10, |w| w.write_bytes(&self.1.link.to_bytes()))?;
                w.write_with_tag(18, |w| w.write_string((self.0).0.as_str()))?;
                w.write_with_tag(24, |w| w.write_uint64((self.0).2))?;
                Ok(())
            }
        }

        impl<'a> BTreeMappedDir<'a> {
            fn mapped(&self) -> impl Iterator<Item = EntryAsPBLink<'_>> + '_ {
                self.links
                    .iter()
                    .map(|triple| triple.as_ref().map(|l| EntryAsPBLink(l)).unwrap())
            }
        }

        impl<'a> MessageWrite for BTreeMappedDir<'a> {
            fn get_size(&self) -> usize {
                use quick_protobuf::sizeofs::*;

                let links = self
                    .mapped()
                    .map(|link| 1 + sizeof_len(link.get_size()))
                    .sum::<usize>();

                links + 1 + sizeof_len(self.data.get_size())
            }
            fn write_message<W: WriterBackend>(
                &self,
                w: &mut Writer<W>,
            ) -> quick_protobuf::Result<()> {
                for l in self.mapped() {
                    w.write_with_tag(18, |w| w.write_message(&l))?;
                }
                w.write_with_tag(10, |w| w.write_message(&self.data))
            }
        }

        let btreed = BTreeMappedDir {
            links,
            data: UnixFs {
                Type: UnixFsType::Directory,
                ..Default::default()
            },
        };

        /*

        use crate::pb::{FlatUnixFs, PBLink};
        use std::borrow::Cow;
        let btreed = FlatUnixFs {
            links: links
                .iter() // .drain() would be the most reasonable
                .map(|(name, Leaf { link, total_size })| PBLink {
                    Hash: Some(link.to_bytes().into()),
                    Name: Some(Cow::Borrowed(name.as_str())),
                    Tsize: Some(*total_size),
                })
                .collect::<Vec<_>>(),
            data: UnixFs {
                Type: UnixFsType::Directory,
                ..Default::default()
            },
        };*/
        /**/
        let size = btreed.get_size();

        if let Some(limit) = block_size_limit {
            let size = size as u64;
            if *limit < size {
                // FIXME: this could probably be detected at
                return Err(TreeConstructionFailed::TooLargeBlock(size));
            }
        }

        // FIXME: we shouldn't be creating too large structures (bitswap block size limit!)
        // FIXME: changing this to autosharding is going to take some thinking

        let cap = buffer.capacity();

        if let Some(additional) = size.checked_sub(cap) {
            buffer.reserve(additional);
        }

        if let Some(needed_zeroes) = size.checked_sub(buffer.len()) {
            buffer.extend(std::iter::repeat(0).take(needed_zeroes));
        }

        let mut writer = Writer::new(BytesWriter::new(&mut buffer[..]));
        btreed
            .write_message(&mut writer)
            .map_err(TreeConstructionFailed::Protobuf)?;

        buffer.truncate(size);

        let mh = multihash::wrap(multihash::Code::Sha2_256, &Sha256::digest(&buffer));
        let cid = Cid::new_v0(mh).expect("sha2_256 is the correct multihash for cidv0");

        let combined_from_links = links
            .iter()
            .map(|opt| {
                opt.as_ref()
                    .map(|NamedLeaf(_, _, total_size)| total_size)
                    .unwrap()
            })
            .sum::<u64>();

        Ok(Leaf {
            link: cid,
            total_size: buffer.len() as u64 + combined_from_links,
        })
    }

    /// Construct the next dag-pb node, if any.
    ///
    /// Returns a `TreeNode` of the latest constructed tree node.
    pub fn next_borrowed(&mut self) -> Option<Result<TreeNode<'_>, TreeConstructionFailed>> {
        while let Some(visited) = self.pending.pop() {
            let (name, depth) = match &visited {
                Visited::DescentRoot(_) => (None, 0),
                Visited::Descent { name, depth, .. } => (Some(name.as_ref()), *depth),
                Visited::Post { name, depth, .. } => (Some(name.as_ref()), *depth),
                Visited::PostRoot { .. } => (None, 0),
            };

            update_full_path((&mut self.full_path, &mut self.old_depth), name, depth);

            match visited {
                Visited::DescentRoot(node) => {
                    let children = &mut self.reused_children;

                    let leaves = partition_children_leaves(depth, node.nodes.into_iter(), children);

                    // initial idea was to validate something with

                    let any_children = !children.is_empty();

                    let leaves = if any_children {
                        // we only need to put the leaves in there in the case of wrapping
                        self.persisted_cids.insert(node.id, leaves);
                        LeafStorage::from(node.id)
                    } else {
                        leaves.into()
                    };

                    self.pending.push(Visited::PostRoot { leaves });
                    self.pending.extend(children.drain(..));
                }
                Visited::Descent {
                    node,
                    name,
                    depth,
                    index,
                } => {
                    let children = &mut self.reused_children;

                    let leaves = partition_children_leaves(depth, node.nodes.into_iter(), children);

                    let any_children = !children.is_empty();

                    // this would be none for only the single first node, however we know already
                    // this is not the branch DescentRoot
                    let parent_id = node.parent_id.expect("this is not root");

                    let leaves = if any_children {
                        self.persisted_cids.insert(node.id, leaves);
                        node.id.into()
                    } else {
                        leaves.into()
                    };

                    self.pending.push(Visited::Post {
                        parent_id,
                        name,
                        depth,
                        leaves,
                        index,
                    });

                    self.pending.extend(children.drain(..));
                }
                Visited::Post {
                    parent_id,
                    name,
                    leaves,
                    index,
                    ..
                } => {
                    let leaves = leaves.into_inner(&mut self.persisted_cids);

                    let buffer = &mut self.block_buffer;

                    let leaf = match Self::render_directory(
                        &leaves,
                        buffer,
                        &self.opts.block_size_limit,
                    ) {
                        Ok(leaf) => leaf,
                        Err(e) => return Some(Err(e)),
                    };

                    self.cid = Some(leaf.link.clone());
                    self.total_size = leaf.total_size;

                    {
                        // name is None only for wrap_with_directory, which cannot really be
                        // propagated up but still the parent_id is allowed to be None
                        let parent_leaves = self.persisted_cids.get_mut(&parent_id);

                        match (parent_id, parent_leaves, index) {
                            (pid, None, index) => panic!(
                                "leaves not found for parent_id = {} and index = {}",
                                pid, index
                            ),
                            (_, Some(vec), index) => {
                                let cell = &mut vec[index];
                                // all
                                assert!(cell.is_none());
                                *cell = Some(NamedLeaf(name, leaf.link, leaf.total_size));
                            }
                        }
                    }

                    return Some(Ok(TreeNode {
                        path: self.full_path.as_str(),
                        cid: self.cid.as_ref().unwrap(),
                        total_size: self.total_size,
                        block: &self.block_buffer,
                    }));
                }
                Visited::PostRoot { leaves } => {
                    let leaves = leaves.into_inner(&mut self.persisted_cids);

                    if !self.opts.wrap_with_directory {
                        break;
                    }

                    let buffer = &mut self.block_buffer;

                    let leaf = match Self::render_directory(
                        &leaves,
                        buffer,
                        &self.opts.block_size_limit,
                    ) {
                        Ok(leaf) => leaf,
                        Err(e) => return Some(Err(e)),
                    };

                    self.cid = Some(leaf.link.clone());
                    self.total_size = leaf.total_size;

                    return Some(Ok(TreeNode {
                        path: self.full_path.as_str(),
                        cid: self.cid.as_ref().unwrap(),
                        total_size: self.total_size,
                        block: &self.block_buffer,
                    }));
                }
            }
        }
        None
    }
}

impl Iterator for PostOrderIterator {
    type Item = Result<OwnedTreeNode, TreeConstructionFailed>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_borrowed()
            .map(|res| res.map(TreeNode::into_owned))
    }
}

/// Borrowed representation of a node in the tree.
pub struct TreeNode<'a> {
    /// Full path to the node.
    pub path: &'a str,
    /// The Cid of the document.
    pub cid: &'a Cid,
    /// Cumulative total size of the subtree in bytes.
    pub total_size: u64,
    /// Raw dag-pb document.
    pub block: &'a [u8],
}

impl<'a> fmt::Debug for TreeNode<'a> {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt.debug_struct("TreeNode")
            .field("path", &format_args!("{:?}", self.path))
            .field("cid", &format_args!("{}", self.cid))
            .field("total_size", &self.total_size)
            .field("size", &self.block.len())
            .finish()
    }
}

impl TreeNode<'_> {
    /// Convert to an owned and detached representation.
    pub fn into_owned(self) -> OwnedTreeNode {
        OwnedTreeNode {
            path: self.path.to_owned(),
            cid: self.cid.to_owned(),
            total_size: self.total_size,
            block: self.block.into(),
        }
    }
}

/// Owned representation of a node in the tree.
pub struct OwnedTreeNode {
    /// Full path to the node.
    pub path: String,
    /// The Cid of the document.
    pub cid: Cid,
    /// Cumulative total size of the subtree in bytes.
    pub total_size: u64,
    /// Raw dag-pb document.
    pub block: Box<[u8]>,
}

fn update_full_path(
    (full_path, old_depth): (&mut String, &mut usize),
    name: Option<&str>,
    depth: usize,
) {
    if depth < 2 {
        // initially thought it might be a good idea to add a slash to all components; removing it made
        // it impossible to get back down to empty string, so fixing this for depths 0 and 1.
        full_path.clear();
        *old_depth = 0;
    } else {
        while *old_depth >= depth && *old_depth > 0 {
            // we now want to pop the last segment
            // this would be easier with PathBuf
            let slash_at = full_path.bytes().rposition(|ch| ch == b'/');
            if let Some(slash_at) = slash_at {
                if *old_depth == depth && Some(&full_path[(slash_at + 1)..]) == name {
                    // minor unmeasurable perf optimization:
                    // going from a/b/foo/zz => a/b/foo does not need to go through the a/b
                    return;
                }
                full_path.truncate(slash_at);
                *old_depth -= 1;
            } else {
                todo!(
                    "no last slash_at in {:?} yet {} >= {}",
                    full_path,
                    old_depth,
                    depth
                );
            }
        }
    }

    debug_assert!(*old_depth <= depth);

    if let Some(name) = name {
        if !full_path.is_empty() {
            full_path.push_str("/");
        }
        full_path.push_str(name);
        *old_depth += 1;
    }

    assert_eq!(*old_depth, depth);
    // eprintln!("{:>4} {:?}", depth, full_path);
}

fn partition_children_leaves(
    depth: usize,
    it: impl Iterator<Item = (String, Entry)>,
    children: &mut Vec<Visited>,
) -> Leaves {
    let mut leaves = Vec::new();

    for (i, (k, v)) in it.enumerate() {
        match v {
            Entry::Directory(node) => {
                children.push(Visited::Descent {
                    node,
                    // this needs to be pushed down to update the full_path
                    name: k,
                    depth: depth + 1,
                    index: i,
                });

                // this will be overwritten later, but the order is fixed
                leaves.push(None);
            }
            Entry::Leaf(leaf) => leaves.push(Some(NamedLeaf(k, leaf.link, leaf.total_size))),
        }
    }

    leaves
}

#[derive(Debug)]
enum LeafStorage {
    Direct(Leaves),
    Stashed(u64),
}

impl LeafStorage {
    fn into_inner(self, stash: &mut HashMap<u64, Leaves>) -> Leaves {
        use LeafStorage::*;

        match self {
            Direct(leaves) => leaves,
            Stashed(id) => stash
                .remove(&id)
                .ok_or(id)
                .expect("could not find stashed leaves"),
        }
    }
}

impl From<u64> for LeafStorage {
    fn from(key: u64) -> LeafStorage {
        LeafStorage::Stashed(key)
    }
}

impl From<Leaves> for LeafStorage {
    fn from(leaves: Leaves) -> LeafStorage {
        LeafStorage::Direct(leaves)
    }
}
